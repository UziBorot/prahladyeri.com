<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom"><title>Prahlad Yeri - Freelance Programmer - Python, Technology</title><link href="/" rel="alternate"></link><link href="feeds/python-technology.atom.xml" rel="self"></link><id>/</id><updated>2017-06-25T04:21:00+05:30</updated><entry><title>Flask Recipe - RESTful CRUD using sqlalchemy</title><link href="blog/2017/06/flask-recipe-restful-crud-using-sqlalchemy.html" rel="alternate"></link><published>2017-06-25T04:21:00+05:30</published><updated>2017-06-25T04:21:00+05:30</updated><author><name>Prahlad Yeri</name></author><id>tag:None,2017-06-25:blog/2017/06/flask-recipe-restful-crud-using-sqlalchemy.html</id><summary type="html">&lt;p&gt;RESTful apps are a thing these days. When your application’s userbase gets quite large and the client could vary from a laptop to an android device to an iOS device, it pays to keep the backend code separate and use the server only for making RESTful calls using HTTP …&lt;/p&gt;</summary><content type="html">&lt;p&gt;RESTful apps are a thing these days. When your application’s userbase gets quite large and the client could vary from a laptop to an android device to an iOS device, it pays to keep the backend code separate and use the server only for making RESTful calls using HTTP methods that pertain to basic OLTP transactions: SELECT, INSERT, UPDATE and DELETE.&lt;!--more--&gt;&lt;/p&gt;
&lt;p&gt;Popular third-party apps like &lt;a href="https://en.wikipedia.org/wiki/Firebase#Realtime_Database"&gt;Firebase&lt;/a&gt; essentially provide you this same thing - A REST based front to a database that could be accessed online using simple HTTP methods. But in this tutorial, we will learn how to create such a backend ourselves using Python’s &lt;code class="highlighter-rouge"&gt;flask&lt;/code&gt; framework and &lt;code class="highlighter-rouge"&gt;sqlalchemy&lt;/code&gt;, a light-weight but powerful ORM library that can access ANY database using its flexible &lt;em&gt;sql expression language&lt;/em&gt;.&lt;/p&gt;
&lt;p&gt;&lt;img alt="RESTful CRUD App" src="/uploads/old/restful-crud.png"&gt;&lt;/p&gt;
&lt;p&gt;Rather than using firebase, if you develop your own implementation of your back-end, not only will it help you learn and become a better programmer, but also give you a flexible solution that you can scale and change as per your needs. Its also much cheaper to host your own solution on Amazon EC2 (or Lambda) compared to other costlier alternatives.&lt;/p&gt;
&lt;p&gt;Contrary to popular thinking, its not very difficult to create a database agnostic backend such as the one represented in the above diagram. With a minimal and powerful web framework such as &lt;code class="highlighter-rouge"&gt;flask&lt;/code&gt;, combined with the power of &lt;code class="highlighter-rouge"&gt;sqlalchemy&lt;/code&gt;, you can get up and running within minutes. In fact, I’ve developed a prototype version called &lt;a href="https://github.com/prahladyeri/tiddly"&gt;Tiddly&lt;/a&gt; that essentially does the same thing as above using just 172 lines of Python code. You can refer to that github repository for reference as we proceed through this tutorial, or directly start using it. But make sure you install the following dependencies before running it:&lt;/p&gt;
&lt;figure class="highlight"&gt;
    pip install flask
    pip install sqlalchemy

&lt;/figure&gt;

&lt;p&gt;The first step towards creating the app is creating your database models. Once you’ve done the brainstorming and decided what tables and fields you are going to need, you can create a &lt;code class="highlighter-rouge"&gt;models.py&lt;/code&gt; source file with something like this:&lt;/p&gt;
&lt;figure class="highlight"&gt;
    import sqlalchemy
    from sqlalchemy import create_engine
    from sqlalchemy import Column, String, Integer
    from sqlalchemy.orm import sessionmaker
    from sqlalchemy.ext.declarative import declarative_base

    #TODO: Change as needed:
    engine = create_engine("sqlite:///tiddly.db", echo=True)
    Base = declarative_base()

    Session = sessionmaker(bind=engine)
    dbsession = Session()

    class User(Base):
        __tablename__ = "user"
        id = Column(Integer, primary_key=True)
        email = Column(String)
        password = Column(String)
        name = Column(String)
        def repr(self):
            return "&lt;User(name=%s, email=%s, )&gt;" % (name, email)

    class Dual(Base):
        __tablename__ = "dual"
        id = Column(Integer, primary_key=True)
        text = Column(String)
        def repr(self):
            return "&lt;Dual(id=%s, text=%s, )&gt;" % (id, text)

&lt;/figure&gt;

&lt;p&gt;I’m using sqlite database for example here, but you can use any one of your choice. A &lt;code class="highlighter-rouge"&gt;user&lt;/code&gt; table is a pretty basic one in almost every app as it is used for authentication. Apart from that, I’ve also created a &lt;code class="highlighter-rouge"&gt;dual&lt;/code&gt; table just to play around with.&lt;/p&gt;
&lt;p&gt;After that, create the second file &lt;code class="highlighter-rouge"&gt;app.py&lt;/code&gt; that contains our application code. Define the following import statements along with your models as they will come very handy:&lt;/p&gt;
&lt;figure class="highlight"&gt;
    import flask
    from flask import request, jsonify, session
    import sqlalchemy
    from sqlalchemy import inspect, desc
    import json
    import models
    from models import engine, dbsession

&lt;/figure&gt;

&lt;p&gt;Now, the only thing that remains to be done is the plumbing the &lt;code class="highlighter-rouge"&gt;HTTP&lt;/code&gt; methods to their respective database operations. You can either create a separate view function for each one or use a single one for all of them. In this example, I’m using a single function for simplicity.&lt;/p&gt;
&lt;figure class="highlight"&gt;
    @app.route("/&lt;table_name&gt;", methods=["POST", "PUT", "DELETE", "FETCH"])
    def fetch(table_name):
        print("verb: %s, tablename: %s" % (request.method, table_name))
        if request.method == "POST" or request.method == "PUT":
            data = request.get_json(force=True)
            print("data:", data)
            try:
                TableClass = models.get_class_by_tablename(table_name)
                if TableClass == None: raise Exception("Table not found: %s" % table_name)
                if request.method == "POST": #insert data
                    object = TableClass(**data)
                    dbsession.add(object)
                    dbsession.commit()
                else: #update data
                    object = dbsession.query(TableClass).filter_by(**{"id":id}).first()
                    if object == None: raise Exception("No data found.")
                    #object.update(**data)
                    for key in data.keys():
                        setattr(object, key, data[key])
                    #dbsession.add(object)
                    dbsession.commit()
                return jsonify({
                    "status": "success",
                    "id": object.id,
                    })
            except Exception as e:
                return jsonify({
                    "status": "error",
                    "error": str(e),
                    })
        elif request.method == "DELETE":
            try:
                TableClass = models.get_class_by_tablename(table_name)
                if TableClass == None: raise Exception("Table not found: %s" % table_name)
                object = dbsession.query(TableClass).filter_by(**{"id":id}).first()
                if object == None: raise Exception("No data found.")
                dbsession.delete(object)
                dbsession.commit()
                return jsonify({
                    "status": "success",
                    "id": object.id,
                    })
            except Exception as e:
                return jsonify({
                    "status": "error",
                    "error": str(e),
                    })
        elif request.method == "FETCH":
            try:
                data = request.get_json(force=True)
                data = json.loads(data)
                print("data: ", data)
                print("data-type: ", type(data))
                TableClass = models.get_class_by_tablename(table_name)
                if TableClass == None: raise Exception("Table not found: %s" % table_name)

                query = dbsession.query(TableClass).filter_by(**data['where'])
                if 'orderby' in data:
                    for cname in data['orderby'].split(','):
                        reverse = False
                        if cname.endswith(' desc'):
                            reverse = True
                            cname = cname[:-5]
                        elif cname.endswith(' asc'):
                            cname = cname[:-4]
                        print("cname: ", cname)
                        column = getattr(TableClass, cname)
                        if reverse: column = desc(column)
                        query = query.order_by(column)
                if 'limit' in data:
                    query = query.limit(data['limit'])
                    query = query.offset(data['offset'])
                object = query.all()
                data = [object_as_dict(t) for t in object]
                return jsonify({
                    "status": "success", 
                    "data": data
                    })
            except Exception as e:
                return jsonify({
                    "status": "error",
                    "error": str(e),
                    })
        else:
            return jsonify({
                "status": "error", "error": "Unrecognized verb.",
                })

&lt;/figure&gt;

&lt;p&gt;I’ve used a non-standard HTTP method, &lt;code class="highlighter-rouge"&gt;FETCH&lt;/code&gt; for the &lt;code class="highlighter-rouge"&gt;SELECT&lt;/code&gt; action. That’s because if you use the &lt;code class="highlighter-rouge"&gt;GET&lt;/code&gt; method, you aren’t allowed to actually post data (as in actual posting, don’t confuse with &lt;code class="highlighter-rouge"&gt;POST&lt;/code&gt; method) as per the HTTP specification. The other methods, viz &lt;code class="highlighter-rouge"&gt;POST&lt;/code&gt;, &lt;code class="highlighter-rouge"&gt;PUT&lt;/code&gt; and &lt;code class="highlighter-rouge"&gt;DELETE&lt;/code&gt; are self-apparent and they stand for &lt;code class="highlighter-rouge"&gt;INSERT&lt;/code&gt;, &lt;code class="highlighter-rouge"&gt;UPDATE&lt;/code&gt; and &lt;code class="highlighter-rouge"&gt;DELETE&lt;/code&gt; actions respectively.&lt;/p&gt;
&lt;p&gt;As you can see, the app makes good use of the sql expression language of sqlalchemy to dynamically query any kind of data, not only using the usual &lt;code class="highlighter-rouge"&gt;where&lt;/code&gt; clause, but also using ordering and pagination (limit/offset) parameters:&lt;/p&gt;
&lt;figure class="highlight"&gt;
    if 'orderby' in data:
        for cname in data['orderby'].split(','):
            reverse = False
            if cname.endswith(' desc'):
                reverse = True
                cname = cname[:-5]
            elif cname.endswith(' asc'):
                cname = cname[:-4]
            print("cname: ", cname)
            column = getattr(TableClass, cname)
            if reverse: column = desc(column)
            query = query.order_by(column)
    if 'limit' in data:
        query = query.limit(data['limit'])
        query = query.offset(data['offset'])

&lt;/figure&gt;

&lt;p&gt;The front-end sends whatever it needs to the back-end using JSON format and the result is also in JSON. For example, the following JSON when posted to &lt;code class="highlighter-rouge"&gt;/user&lt;/code&gt; endpoint using &lt;code class="highlighter-rouge"&gt;FETCH&lt;/code&gt; method, returns the record from user table where &lt;code class="highlighter-rouge"&gt;name&lt;/code&gt; field matches &lt;code class="highlighter-rouge"&gt;admin&lt;/code&gt; and orders the results by email in descending order.&lt;/p&gt;
&lt;figure class="highlight"&gt;
    {"where": {"name":"admin"}, "orderby": "email desc"}

&lt;/figure&gt;

&lt;p&gt;Adding the &lt;code class="highlighter-rouge"&gt;limit&lt;/code&gt; and &lt;code class="highlighter-rouge"&gt;offset&lt;/code&gt; clauses to the same can help the front-end with pagination.&lt;/p&gt;
&lt;figure class="highlight"&gt;
    {"where": {"name":"admin"}, "orderby": "email desc", "limit":2, "offset": 2}

&lt;/figure&gt;

&lt;p&gt;Its also pretty trivial to implement user authentication with this design. I haven’t done it in this example for simplicity, but you can find it in the &lt;a href="https://github.com/prahladyeri/tiddly"&gt;github code&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;All code in this tutorial and on github is &lt;code class="highlighter-rouge"&gt;MIT&lt;/code&gt; licensed and free to use. So, enjoy coding, build your own RESTful CRUD app, and let me know how it goes via comments below!&lt;/p&gt;</content><category term="Flask"></category><category term="Python"></category><category term="SQLAlchemy"></category></entry></feed>